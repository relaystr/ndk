/// Bundled nostr-tools verification JS code.
/// Generated from lib/assets/nostr_verify.src.js using esbuild.
/// To regenerate: cd lib/assets && npm run build && update this file.
const String nostrVerifyJs = r'''
var NostrVerifierModule=(()=>{function It(n){return n instanceof Uint8Array||ArrayBuffer.isView(n)&&n.constructor.name==="Uint8Array"}function J(n,t=""){if(!Number.isSafeInteger(n)||n<0){let r=t&&`"${t}" `;throw new Error(`${r}expected integer >= 0, got ${n}`)}}function I(n,t,r=""){let e=It(n),o=n?.length,s=t!==void 0;if(!e||s&&o!==t){let c=r&&`"${r}" `,i=s?` of length ${t}`:"",f=e?`length=${o}`:`type=${typeof n}`;throw new Error(c+"expected Uint8Array"+i+", got "+f)}return n}function Ot(n,t=!0){if(n.destroyed)throw new Error("Hash instance has been destroyed");if(t&&n.finished)throw new Error("Hash#digest() has already been called")}function te(n,t){I(n,void 0,"digestInto() output");let r=t.outputLen;if(n.length<r)throw new Error('"digestInto() output" expected to be of length >='+r)}function st(...n){for(let t=0;t<n.length;t++)n[t].fill(0)}function xt(n){return new DataView(n.buffer,n.byteOffset,n.byteLength)}function C(n,t){return n<<32-t|n>>>t}var ee=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",Te=Array.from({length:256},(n,t)=>t.toString(16).padStart(2,"0"));function G(n){if(I(n),ee)return n.toHex();let t="";for(let r=0;r<n.length;r++)t+=Te[n[r]];return t}var K={_0:48,_9:57,A:65,F:70,a:97,f:102};function Ft(n){if(n>=K._0&&n<=K._9)return n-K._0;if(n>=K.A&&n<=K.F)return n-(K.A-10);if(n>=K.a&&n<=K.f)return n-(K.a-10)}function it(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);if(ee)return Uint8Array.fromHex(n);let t=n.length,r=t/2;if(t%2)throw new Error("hex string expected, got unpadded hex of length "+t);let e=new Uint8Array(r);for(let o=0,s=0;o<r;o++,s+=2){let c=Ft(n.charCodeAt(s)),i=Ft(n.charCodeAt(s+1));if(c===void 0||i===void 0){let f=n[s]+n[s+1];throw new Error('hex string expected, got non-hex character "'+f+'" at index '+s)}e[o]=c*16+i}return e}function Y(...n){let t=0;for(let e=0;e<n.length;e++){let o=n[e];I(o),t+=o.length}let r=new Uint8Array(t);for(let e=0,o=0;e<n.length;e++){let s=n[e];r.set(s,o),o+=s.length}return r}function ne(n,t={}){let r=(o,s)=>n(s).update(o).digest(),e=n(void 0);return r.outputLen=e.outputLen,r.blockLen=e.blockLen,r.create=o=>n(o),Object.assign(r,t),Object.freeze(r)}function ct(n=32){let t=typeof globalThis=="object"?globalThis.crypto:null;if(typeof t?.getRandomValues!="function")throw new Error("crypto.getRandomValues must be defined");return t.getRandomValues(new Uint8Array(n))}var re=n=>({oid:Uint8Array.from([6,9,96,134,72,1,101,3,4,2,n])});function oe(n,t,r){return n&t^~n&r}function se(n,t,r){return n&t^n&r^t&r}var gt=class{blockLen;outputLen;padOffset;isLE;buffer;view;finished=!1;length=0;pos=0;destroyed=!1;constructor(t,r,e,o){this.blockLen=t,this.outputLen=r,this.padOffset=e,this.isLE=o,this.buffer=new Uint8Array(t),this.view=xt(this.buffer)}update(t){Ot(this),I(t);let{view:r,buffer:e,blockLen:o}=this,s=t.length;for(let c=0;c<s;){let i=Math.min(o-this.pos,s-c);if(i===o){let f=xt(t);for(;o<=s-c;c+=o)this.process(f,c);continue}e.set(t.subarray(c,c+i),this.pos),this.pos+=i,c+=i,this.pos===o&&(this.process(r,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){Ot(this),te(t,this),this.finished=!0;let{buffer:r,view:e,blockLen:o,isLE:s}=this,{pos:c}=this;r[c++]=128,st(this.buffer.subarray(c)),this.padOffset>o-c&&(this.process(e,0),c=0);for(let d=c;d<o;d++)r[d]=0;e.setBigUint64(o-8,BigInt(this.length*8),s),this.process(e,0);let i=xt(t),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen must be aligned to 32bit");let u=f/4,h=this.get();if(u>h.length)throw new Error("_sha2: outputLen bigger than state");for(let d=0;d<u;d++)i.setUint32(4*d,h[d],s)}digest(){let{buffer:t,outputLen:r}=this;this.digestInto(t);let e=t.slice(0,r);return this.destroy(),e}_cloneInto(t){t||=new this.constructor,t.set(...this.get());let{blockLen:r,buffer:e,length:o,finished:s,destroyed:c,pos:i}=this;return t.destroyed=c,t.finished=s,t.length=o,t.pos=i,o%r&&t.buffer.set(e),t}clone(){return this._cloneInto()}},j=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]);var De=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),z=new Uint32Array(64),_t=class extends gt{constructor(t){super(64,t,8,!1)}get(){let{A:t,B:r,C:e,D:o,E:s,F:c,G:i,H:f}=this;return[t,r,e,o,s,c,i,f]}set(t,r,e,o,s,c,i,f){this.A=t|0,this.B=r|0,this.C=e|0,this.D=o|0,this.E=s|0,this.F=c|0,this.G=i|0,this.H=f|0}process(t,r){for(let d=0;d<16;d++,r+=4)z[d]=t.getUint32(r,!1);for(let d=16;d<64;d++){let p=z[d-15],g=z[d-2],O=C(p,7)^C(p,18)^p>>>3,_=C(g,17)^C(g,19)^g>>>10;z[d]=_+z[d-7]+O+z[d-16]|0}let{A:e,B:o,C:s,D:c,E:i,F:f,G:u,H:h}=this;for(let d=0;d<64;d++){let p=C(i,6)^C(i,11)^C(i,25),g=h+p+oe(i,f,u)+De[d]+z[d]|0,_=(C(e,2)^C(e,13)^C(e,22))+se(e,o,s)|0;h=u,u=f,f=i,i=c+g|0,c=s,s=o,o=e,e=g+_|0}e=e+this.A|0,o=o+this.B|0,s=s+this.C|0,c=c+this.D|0,i=i+this.E|0,f=f+this.F|0,u=u+this.G|0,h=h+this.H|0,this.set(e,o,s,c,i,f,u,h)}roundClean(){st(z)}destroy(){this.set(0,0,0,0,0,0,0,0),st(this.buffer)}},Ht=class extends _t{A=j[0]|0;B=j[1]|0;C=j[2]|0;D=j[3]|0;E=j[4]|0;F=j[5]|0;G=j[6]|0;H=j[7]|0;constructor(){super(32)}};var ft=ne(()=>new Ht,re(1));var Lt=BigInt(0),qt=BigInt(1);function Nt(n,t=""){if(typeof n!="boolean"){let r=t&&`"${t}" `;throw new Error(r+"expected boolean, got type="+typeof n)}return n}function Ve(n){if(typeof n=="bigint"){if(!Ce(n))throw new Error("positive bigint expected, got "+n)}else J(n);return n}function ie(n){if(typeof n!="string")throw new Error("hex string expected, got "+typeof n);return n===""?Lt:BigInt("0x"+n)}function P(n){return ie(G(n))}function Ut(n){return ie(G(Ze(I(n)).reverse()))}function mt(n,t){J(t),n=Ve(n);let r=it(n.toString(16).padStart(t*2,"0"));if(r.length!==t)throw new Error("number too large");return r}function Tt(n,t){return mt(n,t).reverse()}function Ze(n){return Uint8Array.from(n)}function ce(n){return Uint8Array.from(n,(t,r)=>{let e=t.charCodeAt(0);if(t.length!==1||e>127)throw new Error(`string contains non-ASCII character "${n[r]}" with code ${e} at position ${r}`);return e})}var Ce=n=>typeof n=="bigint"&&Lt<=n;function Dt(n){let t;for(t=0;n>Lt;n>>=qt,t+=1);return t}var wt=n=>(qt<<BigInt(n))-qt;function yt(n,t={},r={}){if(!n||typeof n!="object")throw new Error("expected valid options object");function e(s,c,i){let f=n[s];if(i&&f===void 0)return;let u=typeof f;if(u!==c||f===null)throw new Error(`param "${s}" is invalid: expected ${c}, got ${u}`)}let o=(s,c)=>Object.entries(s).forEach(([i,f])=>e(i,f,c));o(t,!1),o(r,!0)}function Vt(n){let t=new WeakMap;return(r,...e)=>{let o=t.get(r);if(o!==void 0)return o;let s=n(r,...e);return t.set(r,s),s}}var N=BigInt(0),q=BigInt(1),$=BigInt(2),ue=BigInt(3),de=BigInt(4),le=BigInt(5),ke=BigInt(7),he=BigInt(8),Me=BigInt(9),be=BigInt(16);function k(n,t){let r=n%t;return r>=N?r:t+r}function U(n,t,r){let e=n;for(;t-- >N;)e*=e,e%=r;return e}function fe(n,t){if(n===N)throw new Error("invert: expected non-zero number");if(t<=N)throw new Error("invert: expected positive modulus, got "+t);let r=k(n,t),e=t,o=N,s=q,c=q,i=N;for(;r!==N;){let u=e/r,h=e%r,d=o-c*u,p=s-i*u;e=r,r=h,o=c,s=i,c=d,i=p}if(e!==q)throw new Error("invert: does not exist");return k(o,t)}function Ct(n,t,r){if(!n.eql(n.sqr(t),r))throw new Error("Cannot find square root")}function xe(n,t){let r=(n.ORDER+q)/de,e=n.pow(t,r);return Ct(n,e,t),e}function Ke(n,t){let r=(n.ORDER-le)/he,e=n.mul(t,$),o=n.pow(e,r),s=n.mul(t,o),c=n.mul(n.mul(s,$),o),i=n.mul(s,n.sub(c,n.ONE));return Ct(n,i,t),i}function je(n){let t=F(n),r=ge(n),e=r(t,t.neg(t.ONE)),o=r(t,e),s=r(t,t.neg(e)),c=(n+ke)/be;return(i,f)=>{let u=i.pow(f,c),h=i.mul(u,e),d=i.mul(u,o),p=i.mul(u,s),g=i.eql(i.sqr(h),f),O=i.eql(i.sqr(d),f);u=i.cmov(u,h,g),h=i.cmov(p,d,O);let _=i.eql(i.sqr(h),f),D=i.cmov(u,h,_);return Ct(i,D,f),D}}function ge(n){if(n<ue)throw new Error("sqrt is not defined for small field");let t=n-q,r=0;for(;t%$===N;)t/=$,r++;let e=$,o=F(n);for(;ae(o,e)===1;)if(e++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(r===1)return xe;let s=o.pow(e,t),c=(t+q)/$;return function(f,u){if(f.is0(u))return u;if(ae(f,u)!==1)throw new Error("Cannot find square root");let h=r,d=f.mul(f.ONE,s),p=f.pow(u,t),g=f.pow(u,c);for(;!f.eql(p,f.ONE);){if(f.is0(p))return f.ZERO;let O=1,_=f.sqr(p);for(;!f.eql(_,f.ONE);)if(O++,_=f.sqr(_),O===h)throw new Error("Cannot find square root");let D=q<<BigInt(h-O-1),W=f.pow(d,D);h=O,d=f.sqr(W),p=f.mul(p,d),g=f.mul(g,W)}return g}}function Ge(n){return n%de===ue?xe:n%he===le?Ke:n%be===Me?je(n):ge(n)}var Ye=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function me(n){let t={ORDER:"bigint",BYTES:"number",BITS:"number"},r=Ye.reduce((e,o)=>(e[o]="function",e),t);return yt(n,r),n}function ze(n,t,r){if(r<N)throw new Error("invalid exponent, negatives unsupported");if(r===N)return n.ONE;if(r===q)return t;let e=n.ONE,o=t;for(;r>N;)r&q&&(e=n.mul(e,o)),o=n.sqr(o),r>>=q;return e}function kt(n,t,r=!1){let e=new Array(t.length).fill(r?n.ZERO:void 0),o=t.reduce((c,i,f)=>n.is0(i)?c:(e[f]=c,n.mul(c,i)),n.ONE),s=n.inv(o);return t.reduceRight((c,i,f)=>n.is0(i)?c:(e[f]=n.mul(c,e[f]),n.mul(c,i)),s),e}function ae(n,t){let r=(n.ORDER-q)/$,e=n.pow(t,r),o=n.eql(e,n.ONE),s=n.eql(e,n.ZERO),c=n.eql(e,n.neg(n.ONE));if(!o&&!s&&!c)throw new Error("invalid Legendre symbol result");return o?1:s?0:-1}function $e(n,t){t!==void 0&&J(t);let r=t!==void 0?t:n.toString(2).length,e=Math.ceil(r/8);return{nBitLength:r,nByteLength:e}}var Zt=class{ORDER;BITS;BYTES;isLE;ZERO=N;ONE=q;_lengths;_sqrt;_mod;constructor(t,r={}){if(t<=N)throw new Error("invalid field: expected ORDER > 0, got "+t);let e;this.isLE=!1,r!=null&&typeof r=="object"&&(typeof r.BITS=="number"&&(e=r.BITS),typeof r.sqrt=="function"&&(this.sqrt=r.sqrt),typeof r.isLE=="boolean"&&(this.isLE=r.isLE),r.allowedLengths&&(this._lengths=r.allowedLengths?.slice()),typeof r.modFromBytes=="boolean"&&(this._mod=r.modFromBytes));let{nBitLength:o,nByteLength:s}=$e(t,e);if(s>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");this.ORDER=t,this.BITS=o,this.BYTES=s,this._sqrt=void 0,Object.preventExtensions(this)}create(t){return k(t,this.ORDER)}isValid(t){if(typeof t!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof t);return N<=t&&t<this.ORDER}is0(t){return t===N}isValidNot0(t){return!this.is0(t)&&this.isValid(t)}isOdd(t){return(t&q)===q}neg(t){return k(-t,this.ORDER)}eql(t,r){return t===r}sqr(t){return k(t*t,this.ORDER)}add(t,r){return k(t+r,this.ORDER)}sub(t,r){return k(t-r,this.ORDER)}mul(t,r){return k(t*r,this.ORDER)}pow(t,r){return ze(this,t,r)}div(t,r){return k(t*fe(r,this.ORDER),this.ORDER)}sqrN(t){return t*t}addN(t,r){return t+r}subN(t,r){return t-r}mulN(t,r){return t*r}inv(t){return fe(t,this.ORDER)}sqrt(t){return this._sqrt||(this._sqrt=Ge(this.ORDER)),this._sqrt(this,t)}toBytes(t){return this.isLE?Tt(t,this.BYTES):mt(t,this.BYTES)}fromBytes(t,r=!1){I(t);let{_lengths:e,BYTES:o,isLE:s,ORDER:c,_mod:i}=this;if(e){if(!e.includes(t.length)||t.length>o)throw new Error("Field.fromBytes: expected "+e+" bytes, got "+t.length);let u=new Uint8Array(o);u.set(t,s?0:u.length-t.length),t=u}if(t.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+t.length);let f=s?Ut(t):P(t);if(i&&(f=k(f,c)),!r&&!this.isValid(f))throw new Error("invalid field element: outside of range 0..ORDER");return f}invertBatch(t){return kt(this,t)}cmov(t,r,e){return e?r:t}};function F(n,t={}){return new Zt(n,t)}function we(n){if(typeof n!="bigint")throw new Error("field order must be bigint");let t=n.toString(2).length;return Math.ceil(t/8)}function Xe(n){let t=we(n);return t+Math.ceil(t/2)}function ye(n,t,r=!1){I(n);let e=n.length,o=we(t),s=Xe(t);if(e<16||e<s||e>1024)throw new Error("expected "+s+"-1024 bytes of input, got "+e);let c=r?Ut(n):P(n),i=k(c,t-q)+q;return r?Tt(i,o):mt(i,o)}var tt=BigInt(0),X=BigInt(1);function at(n,t){let r=t.negate();return n?r:t}function Gt(n,t){let r=kt(n.Fp,t.map(e=>e.Z));return t.map((e,o)=>n.fromAffine(e.toAffine(r[o])))}function ve(n,t){if(!Number.isSafeInteger(n)||n<=0||n>t)throw new Error("invalid window size, expected [1.."+t+"], got W="+n)}function Mt(n,t){ve(n,t);let r=Math.ceil(t/n)+1,e=2**(n-1),o=2**n,s=wt(n),c=BigInt(n);return{windows:r,windowSize:e,mask:s,maxNumber:o,shiftBy:c}}function pe(n,t,r){let{windowSize:e,mask:o,maxNumber:s,shiftBy:c}=r,i=Number(n&o),f=n>>c;i>e&&(i-=s,f+=X);let u=t*e,h=u+Math.abs(i)-1,d=i===0,p=i<0,g=t%2!==0;return{nextN:f,offset:h,isZero:d,isNeg:p,isNegF:g,offsetF:u}}var Kt=new WeakMap,Se=new WeakMap;function jt(n){return Se.get(n)||1}function Ee(n){if(n!==tt)throw new Error("invalid wNAF")}var pt=class{BASE;ZERO;Fn;bits;constructor(t,r){this.BASE=t.BASE,this.ZERO=t.ZERO,this.Fn=t.Fn,this.bits=r}_unsafeLadder(t,r,e=this.ZERO){let o=t;for(;r>tt;)r&X&&(e=e.add(o)),o=o.double(),r>>=X;return e}precomputeWindow(t,r){let{windows:e,windowSize:o}=Mt(r,this.bits),s=[],c=t,i=c;for(let f=0;f<e;f++){i=c,s.push(i);for(let u=1;u<o;u++)i=i.add(c),s.push(i);c=i.double()}return s}wNAF(t,r,e){if(!this.Fn.isValid(e))throw new Error("invalid scalar");let o=this.ZERO,s=this.BASE,c=Mt(t,this.bits);for(let i=0;i<c.windows;i++){let{nextN:f,offset:u,isZero:h,isNeg:d,isNegF:p,offsetF:g}=pe(e,i,c);e=f,h?s=s.add(at(p,r[g])):o=o.add(at(d,r[u]))}return Ee(e),{p:o,f:s}}wNAFUnsafe(t,r,e,o=this.ZERO){let s=Mt(t,this.bits);for(let c=0;c<s.windows&&e!==tt;c++){let{nextN:i,offset:f,isZero:u,isNeg:h}=pe(e,c,s);if(e=i,!u){let d=r[f];o=o.add(h?d.negate():d)}}return Ee(e),o}getPrecomputes(t,r,e){let o=Kt.get(r);return o||(o=this.precomputeWindow(r,t),t!==1&&(typeof e=="function"&&(o=e(o)),Kt.set(r,o))),o}cached(t,r,e){let o=jt(t);return this.wNAF(o,this.getPrecomputes(o,t,e),r)}unsafe(t,r,e,o){let s=jt(t);return s===1?this._unsafeLadder(t,r,o):this.wNAFUnsafe(s,this.getPrecomputes(s,t,e),r,o)}createCache(t,r){ve(r,this.bits),Se.set(t,r),Kt.delete(t)}hasCache(t){return jt(t)!==1}};function Ae(n,t,r,e){let o=t,s=n.ZERO,c=n.ZERO;for(;r>tt||e>tt;)r&X&&(s=s.add(o)),e&X&&(c=c.add(o)),o=o.double(),r>>=X,e>>=X;return{p1:s,p2:c}}function Be(n,t,r){if(t){if(t.ORDER!==n)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return me(t),t}else return F(n,{isLE:r})}function Re(n,t,r={},e){if(e===void 0&&(e=n==="edwards"),!t||typeof t!="object")throw new Error(`expected valid ${n} CURVE object`);for(let f of["p","n","h"]){let u=t[f];if(!(typeof u=="bigint"&&u>tt))throw new Error(`CURVE.${f} must be positive bigint`)}let o=Be(t.p,r.Fp,e),s=Be(t.n,r.Fn,e),i=["Gx","Gy","a",n==="weierstrass"?"b":"d"];for(let f of i)if(!o.isValid(t[f]))throw new Error(`CURVE.${f} must be valid field element of CURVE.Fp`);return t=Object.freeze(Object.assign({},t)),{CURVE:t,Fp:o,Fn:s}}function Yt(n,t){return function(e){let o=n(e);return{secretKey:o,publicKey:t(o)}}}var Ie=(n,t)=>(n+(n>=0?t:-t)/Qe)/t;function We(n,t,r){let[[e,o],[s,c]]=t,i=Ie(c*n,r),f=Ie(-o*n,r),u=n-i*e-f*s,h=-i*o-f*c,d=u<ut,p=h<ut;d&&(u=-u),p&&(h=-h);let g=wt(Math.ceil(Dt(r)/2))+Bt;if(u<ut||u>=g||h<ut||h>=g)throw new Error("splitScalar (endomorphism): failed, k="+n);return{k1neg:d,k1:u,k2neg:p,k2:h}}var ut=BigInt(0),Bt=BigInt(1),Qe=BigInt(2),Et=BigInt(3),Je=BigInt(4);function Oe(n,t={}){let r=Re("weierstrass",n,t),{Fp:e,Fn:o}=r,s=r.CURVE,{h:c,n:i}=s;yt(t,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object"});let{endo:f}=t;if(f&&(!e.is0(s.a)||typeof f.beta!="bigint"||!Array.isArray(f.basises)))throw new Error('invalid endo: expected "beta": bigint and "basises": array');let u=Fe(e,o);function h(){if(!e.isOdd)throw new Error("compression is not supported: Field does not have .isOdd()")}function d(v,a,l){let{x,y:m}=a.toAffine(),S=e.toBytes(x);if(Nt(l,"isCompressed"),l){h();let E=!e.isOdd(m);return Y(Pe(E),S)}else return Y(Uint8Array.of(4),S,e.toBytes(m))}function p(v){I(v,void 0,"Point");let{publicKey:a,publicKeyUncompressed:l}=u,x=v.length,m=v[0],S=v.subarray(1);if(x===a&&(m===2||m===3)){let E=e.fromBytes(S);if(!e.isValid(E))throw new Error("bad point: is not on curve, wrong x");let w=_(E),b;try{b=e.sqrt(w)}catch(T){let H=T instanceof Error?": "+T.message:"";throw new Error("bad point: is not on curve, sqrt error"+H)}h();let y=e.isOdd(b);return(m&1)===1!==y&&(b=e.neg(b)),{x:E,y:b}}else if(x===l&&m===4){let E=e.BYTES,w=e.fromBytes(S.subarray(0,E)),b=e.fromBytes(S.subarray(E,E*2));if(!D(w,b))throw new Error("bad point: is not on curve");return{x:w,y:b}}else throw new Error(`bad point: got length ${x}, expected compressed=${a} or uncompressed=${l}`)}let g=t.toBytes||d,O=t.fromBytes||p;function _(v){let a=e.sqr(v),l=e.mul(a,v);return e.add(e.add(l,e.mul(v,s.a)),s.b)}function D(v,a){let l=e.sqr(a),x=_(v);return e.eql(l,x)}if(!D(s.Gx,s.Gy))throw new Error("bad curve params: generator point");let W=e.mul(e.pow(s.a,Et),Je),Rt=e.mul(e.sqr(s.b),BigInt(27));if(e.is0(e.add(W,Rt)))throw new Error("bad curve params: a or b");function rt(v,a,l=!1){if(!e.isValid(a)||l&&e.is0(a))throw new Error(`bad point coordinate ${v}`);return a}function lt(v){if(!(v instanceof R))throw new Error("Weierstrass Point expected")}function ht(v){if(!f||!f.basises)throw new Error("no endo");return We(v,f.basises,o.ORDER)}let bt=Vt((v,a)=>{let{X:l,Y:x,Z:m}=v;if(e.eql(m,e.ONE))return{x:l,y:x};let S=v.is0();a==null&&(a=S?e.ONE:e.inv(m));let E=e.mul(l,a),w=e.mul(x,a),b=e.mul(m,a);if(S)return{x:e.ZERO,y:e.ZERO};if(!e.eql(b,e.ONE))throw new Error("invZ was invalid");return{x:E,y:w}}),Ue=Vt(v=>{if(v.is0()){if(t.allowInfinityPoint&&!e.is0(v.Y))return;throw new Error("bad point: ZERO")}let{x:a,y:l}=v.toAffine();if(!e.isValid(a)||!e.isValid(l))throw new Error("bad point: x or y not field elements");if(!D(a,l))throw new Error("bad point: equation left != right");if(!v.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});function Jt(v,a,l,x,m){return l=new R(e.mul(l.X,v),l.Y,l.Z),a=at(x,a),l=at(m,l),a.add(l)}class R{static BASE=new R(s.Gx,s.Gy,e.ONE);static ZERO=new R(e.ZERO,e.ONE,e.ZERO);static Fp=e;static Fn=o;X;Y;Z;constructor(a,l,x){this.X=rt("x",a),this.Y=rt("y",l,!0),this.Z=rt("z",x),Object.freeze(this)}static CURVE(){return s}static fromAffine(a){let{x:l,y:x}=a||{};if(!a||!e.isValid(l)||!e.isValid(x))throw new Error("invalid affine point");if(a instanceof R)throw new Error("projective point not allowed");return e.is0(l)&&e.is0(x)?R.ZERO:new R(l,x,e.ONE)}static fromBytes(a){let l=R.fromAffine(O(I(a,void 0,"point")));return l.assertValidity(),l}static fromHex(a){return R.fromBytes(it(a))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(a=8,l=!0){return ot.createCache(this,a),l||this.multiply(Et),this}assertValidity(){Ue(this)}hasEvenY(){let{y:a}=this.toAffine();if(!e.isOdd)throw new Error("Field doesn't support isOdd");return!e.isOdd(a)}equals(a){lt(a);let{X:l,Y:x,Z:m}=this,{X:S,Y:E,Z:w}=a,b=e.eql(e.mul(l,w),e.mul(S,m)),y=e.eql(e.mul(x,w),e.mul(E,m));return b&&y}negate(){return new R(this.X,e.neg(this.Y),this.Z)}double(){let{a,b:l}=s,x=e.mul(l,Et),{X:m,Y:S,Z:E}=this,w=e.ZERO,b=e.ZERO,y=e.ZERO,B=e.mul(m,m),T=e.mul(S,S),H=e.mul(E,E),A=e.mul(m,S);return A=e.add(A,A),y=e.mul(m,E),y=e.add(y,y),w=e.mul(a,y),b=e.mul(x,H),b=e.add(w,b),w=e.sub(T,b),b=e.add(T,b),b=e.mul(w,b),w=e.mul(A,w),y=e.mul(x,y),H=e.mul(a,H),A=e.sub(B,H),A=e.mul(a,A),A=e.add(A,y),y=e.add(B,B),B=e.add(y,B),B=e.add(B,H),B=e.mul(B,A),b=e.add(b,B),H=e.mul(S,E),H=e.add(H,H),B=e.mul(H,A),w=e.sub(w,B),y=e.mul(H,T),y=e.add(y,y),y=e.add(y,y),new R(w,b,y)}add(a){lt(a);let{X:l,Y:x,Z:m}=this,{X:S,Y:E,Z:w}=a,b=e.ZERO,y=e.ZERO,B=e.ZERO,T=s.a,H=e.mul(s.b,Et),A=e.mul(l,S),V=e.mul(x,E),Z=e.mul(m,w),Q=e.add(l,x),L=e.add(S,E);Q=e.mul(Q,L),L=e.add(A,V),Q=e.sub(Q,L),L=e.add(l,m);let M=e.add(S,w);return L=e.mul(L,M),M=e.add(A,Z),L=e.sub(L,M),M=e.add(x,m),b=e.add(E,w),M=e.mul(M,b),b=e.add(V,Z),M=e.sub(M,b),B=e.mul(T,L),b=e.mul(H,Z),B=e.add(b,B),b=e.sub(V,B),B=e.add(V,B),y=e.mul(b,B),V=e.add(A,A),V=e.add(V,A),Z=e.mul(T,Z),L=e.mul(H,L),V=e.add(V,Z),Z=e.sub(A,Z),Z=e.mul(T,Z),L=e.add(L,Z),A=e.mul(V,L),y=e.add(y,A),A=e.mul(M,L),b=e.mul(Q,b),b=e.sub(b,A),A=e.mul(Q,V),B=e.mul(M,B),B=e.add(B,A),new R(b,y,B)}subtract(a){return this.add(a.negate())}is0(){return this.equals(R.ZERO)}multiply(a){let{endo:l}=t;if(!o.isValidNot0(a))throw new Error("invalid scalar: out of range");let x,m,S=E=>ot.cached(this,E,w=>Gt(R,w));if(l){let{k1neg:E,k1:w,k2neg:b,k2:y}=ht(a),{p:B,f:T}=S(w),{p:H,f:A}=S(y);m=T.add(A),x=Jt(l.beta,B,H,E,b)}else{let{p:E,f:w}=S(a);x=E,m=w}return Gt(R,[x,m])[0]}multiplyUnsafe(a){let{endo:l}=t,x=this;if(!o.isValid(a))throw new Error("invalid scalar: out of range");if(a===ut||x.is0())return R.ZERO;if(a===Bt)return x;if(ot.hasCache(this))return this.multiply(a);if(l){let{k1neg:m,k1:S,k2neg:E,k2:w}=ht(a),{p1:b,p2:y}=Ae(R,x,S,w);return Jt(l.beta,b,y,m,E)}else return ot.unsafe(x,a)}toAffine(a){return bt(this,a)}isTorsionFree(){let{isTorsionFree:a}=t;return c===Bt?!0:a?a(R,this):ot.unsafe(this,i).is0()}clearCofactor(){let{clearCofactor:a}=t;return c===Bt?this:a?a(R,this):this.multiplyUnsafe(c)}isSmallOrder(){return this.multiplyUnsafe(c).is0()}toBytes(a=!0){return Nt(a,"isCompressed"),this.assertValidity(),g(R,this,a)}toHex(a=!0){return G(this.toBytes(a))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}}let Pt=o.BITS,ot=new pt(R,t.endo?Math.ceil(Pt/2):Pt);return R.BASE.precompute(8),R}function Pe(n){return Uint8Array.of(n?2:3)}function Fe(n,t){return{secretKey:t.BYTES,publicKey:1+n.BYTES,publicKeyUncompressed:1+2*n.BYTES,publicKeyHasPrefix:!0,signature:2*t.BYTES}}var At={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},tn={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},en=BigInt(0),zt=BigInt(2);function nn(n){let t=At.p,r=BigInt(3),e=BigInt(6),o=BigInt(11),s=BigInt(22),c=BigInt(23),i=BigInt(44),f=BigInt(88),u=n*n*n%t,h=u*u*n%t,d=U(h,r,t)*h%t,p=U(d,r,t)*h%t,g=U(p,zt,t)*u%t,O=U(g,o,t)*g%t,_=U(O,s,t)*O%t,D=U(_,i,t)*_%t,W=U(D,f,t)*D%t,Rt=U(W,i,t)*_%t,rt=U(Rt,r,t)*h%t,lt=U(rt,c,t)*O%t,ht=U(lt,e,t)*u%t,bt=U(ht,zt,t);if(!vt.eql(vt.sqr(bt),n))throw new Error("Cannot find square root");return bt}var vt=F(At.p,{sqrt:nn}),et=Oe(At,{Fp:vt,endo:tn});var _e={};function St(n,...t){let r=_e[n];if(r===void 0){let e=ft(ce(n));r=Y(e,e),_e[n]=r}return ft(Y(r,...t))}var Xt=n=>n.toBytes(!0).slice(1),Wt=n=>n%zt===en;function $t(n){let{Fn:t,BASE:r}=et,e=t.fromBytes(n),o=r.multiply(e);return{scalar:Wt(o.y)?e:t.neg(e),bytes:Xt(o)}}function qe(n){let t=vt;if(!t.isValidNot0(n))throw new Error("invalid x: Fail if x \u2265 p");let r=t.create(n*n),e=t.create(r*n+BigInt(7)),o=t.sqrt(e);Wt(o)||(o=t.neg(o));let s=et.fromAffine({x:n,y:o});return s.assertValidity(),s}var dt=P;function Le(...n){return et.Fn.create(dt(St("BIP0340/challenge",...n)))}function He(n){return $t(n).bytes}function rn(n,t,r=ct(32)){let{Fn:e}=et,o=I(n,void 0,"message"),{bytes:s,scalar:c}=$t(t),i=I(r,32,"auxRand"),f=e.toBytes(c^dt(St("BIP0340/aux",i))),u=St("BIP0340/nonce",f,s,o),{bytes:h,scalar:d}=$t(u),p=Le(h,s,o),g=new Uint8Array(64);if(g.set(h,0),g.set(e.toBytes(e.create(d+p*c)),32),!Ne(g,o,s))throw new Error("sign: Invalid signature produced");return g}function Ne(n,t,r){let{Fp:e,Fn:o,BASE:s}=et,c=I(n,64,"signature"),i=I(t,void 0,"message"),f=I(r,32,"publicKey");try{let u=qe(dt(f)),h=dt(c.subarray(0,32));if(!e.isValidNot0(h))return!1;let d=dt(c.subarray(32,64));if(!o.isValidNot0(d))return!1;let p=Le(o.toBytes(h),Xt(u),i),g=s.multiplyUnsafe(d).add(u.multiplyUnsafe(o.neg(p))),{x:O,y:_}=g.toAffine();return!(g.is0()||!Wt(_)||O!==h)}catch{return!1}}var Qt=(()=>{let r=(e=ct(48))=>ye(e,At.n);return{keygen:Yt(r,He),getPublicKey:He,sign:rn,verify:Ne,Point:et,utils:{randomSecretKey:r,taggedHash:St,lift_x:qe,pointToBytes:Xt},lengths:{secretKey:32,publicKey:32,publicKeyHasPrefix:!1,signature:64,seed:48}}})();function on(n){return JSON.stringify([0,n.pubkey,n.created_at,n.kind,n.tags,n.content])}function sn(n){let t=on(n),e=new TextEncoder().encode(t);return G(ft(e))}async function cn(n){try{let t=sn(n);if(n.id!==t)return!1;let r=nt(n.sig),e=nt(n.id),o=nt(n.pubkey);return Qt.verify(r,e,o)}catch(t){return console.error("Event verification error:",t),!1}}async function fn(n,t,r){try{let e=nt(n),o=nt(t),s=nt(r);return Qt.verify(e,o,s)}catch(e){return console.error("Signature verification error:",e),!1}}function nt(n){let t=new Uint8Array(n.length/2);for(let r=0;r<t.length;r++)t[r]=parseInt(n.substr(r*2,2),16);return t}window.NostrVerifier={verifyEvent:cn,verifySignature:fn};})();
/*! Bundled license information:

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/utils.js:
@noble/curves/abstract/modular.js:
@noble/curves/abstract/curve.js:
@noble/curves/abstract/weierstrass.js:
@noble/curves/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
''';
