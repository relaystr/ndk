[[{"i":"dart-nostr-development-kit-ndk","l":"Dart Nostr Development Kit (NDK)","p":["Build Status Coverage Pub License","NDK (Nostr Development Kit) is a Dart library that enhances the Nostr development experience. NDK supplies you with high-level usecases like lists or metadata while still allowing you to use low-level queries enhanced with inbox/outbox (gossip) by default. Our Target is to make it easy to build constrained Nostr clients, particularly for mobile devices.","Home"]},{"i":"features--what-does-ndk-do","l":"Features / what does NDK do?","p":["automatically discover the best relays to satisfy the provided request (using gossip)","cache responses to save network bandwidth","contact list support, you can convert nostr_event to contact_list","nip-42 Authentication of clients to relays","nip-47 Nostr wallet connect","nip-57 Zaps","nip05 caching","nip51 list support, you can convert nostr_event to nip51_list","plug in event signer interface, bring your own event signer, or use included ones: bip340, amber","plug in verifier interface, bring your own event verifier, or use included ones: bip340, rust","plugin cache interface, bring your own db or use included ones: inMemory","publish nostr events to optimal relays or explicit relays","query and subscription, e.g., get data once; subscribe to data.","return nostr data based on filters (any kind).","specify desired coverage on each request (e.g. x relays per pubkey)","stream directly from cache and network (if needed)"]},{"l":"not Included","p":["ready to use feeds, you have to build them on your own (\uD83D\uDEAB not planned)","create && manage keypairs. You have to provide them (\uD83D\uDEAB not planned)","file upload (\uD83D\uDD1C planned)","threading, you can do this on your own if you move ndk or only the event_verifier into its own thread (\uD83D\uDD1C planned)","support for request overrides (you have to close and reopen requests) (\uD83E\uDD14 unsure)"]},{"l":"NIPs","p":["Event Builders / WebSocket Subscriptions ( NIP-01)","User Profiles (edit/follow/unfollow - NIP-02)","Private Messages ( NIP-04)","Nostr Address ( NIP-05)","Event Deletion ( NIP-09)","Relay Info ( NIP-11)","Reactions ( NIP-25)","Lists ( NIP-51)","Relay List Metadata ( NIP-65)","Wallet Connect API ( NIP-47)","Zaps ( NIP-57)","Authentication of clients to relays ( NIP-42)","Encrypted Payloads (Versioned) ( NIP-44)","Bech Encoding support ( NIP-19)","Badges ( NIP-58)"]}],[{"l":"Guides"}],[{"l":"Getting started with NDK"},{"l":"Install","p":["Ndk has a core package ndk and optional packages like rust_verifier and amber."]},{"l":"Import"},{"l":"Usage","p":["We strongly recommend using RustEventVerifier() for client applications. It uses a separate thread for signature verification and is therefore more performant. How to install below.","~~~~~~~~~~~"]},{"l":"Getting started with NDK helper packages"},{"l":"Prerequisites ndk_rust_verifier","p":["android SDK (also for desktop builds)","flutter SDK","rust ( + toolchain for target)","Rust toolchain android:","Rust toolchain ios:"]},{"i":"install-1","l":"Install"},{"i":"import-1","l":"Import"}],[{"l":"Enabling gossip","p":["The simplest way to enable inbox/outbox (gossip) is to use the JIT engine, as it does everything automatically.","For more granular control you can use the RELAY_SETS engine.","To make use of gossip you need to pass a RelaySet to the usecase."]}],[{"l":"Persistence","p":["Ndk comes with several database offerings. The simplest is the MemCacheManager which is an in-memory cache. This is useful for testing and small applications.","Available databases:","MemCacheManager","DbObjectBox","IsarCacheManager","If you want your own database you need to implement the CacheManager interface. Contributions for more database implementations are welcome!","Its recommended to use the database only for ndk and spin up a secondary db for your own app data.","Tip: A simple way to keep your own entities is to use a factory method to convert ndk events to your own entities."]}],[{"l":"Tips"},{"l":"how to keep the ndk obj global","p":["If you have a relatively simple app you can initialize ndk in your main method and pass down ndk on the widget tree. For more more complex applications we recommend using riverpod or simmilar packages/methods (get_it, singletons etc).","riverpod example:"]},{"l":"avoid layout shifts","p":["Sometimes it can make sense to buffer the response from a query and only update the UI periodically.","The package used to achive this is rxdart."]}],[{"l":"Use Cases"}],[{"l":"Blossom"},{"l":"Example"},{"l":"When to use","p":["For a simpler more generic api check out Blossom","If no servers are specified the default user server list (kind 10063) is used for upload and delete.","The auth events get automatically signed and are valid for:"]}],[{"l":"Broadcast"},{"l":"Example"},{"l":"When to use","p":["Broadcast should be used when your use case has no broadcasting method. Signing is done automatically, and you can specify a custom signer just for one broadcast. By default, the inbox/outbox model is used for broadcasting looking at the event data (e.g. if it's a reply) you can also specify specific relays to broadcast to."]}],[{"i":"domain-verification-nip05","l":"Domain verification (nip05)"},{"l":"Example"},{"l":"When to use","p":["Uses caching so there are no repeated network requests if you call this multiple times. Use this when you need to verify a domain. If you call this, the result is automatically used as inbox/outbox information."]}],[{"l":"Files"},{"l":"Example"},{"l":"How to use","p":["Files uses blossom under the hood to get, upload and delete files. The default user server list, specified by kind 10063 is used for upload and delete","If you need more granular control check out: Files"]}],[{"l":"Follows"},{"l":"Example"},{"l":"How to use","p":["Gives you the list of contacts for a given pubKey.","Use broadcastSetContactList() to set the list initially (e.g. on signup) broadcastAddContact() to add a contact to the list broadcastRemoveContact() to remove a contact from the list"]}],[{"l":"Lists"},{"l":"Example"},{"l":"How to use","p":["We distinguish between public and private lists/sets. The methods are prefixed with public or private. Editing lists should be done via the provided broadcast methods."]}],[{"l":"Metadata"},{"l":"Example"},{"l":"How to use","p":["Gives you the metadata for a given pubkey. Uses caching, so repeated calls are ok.","Use broadcastMetadata() to update or set metadata."]}],[{"l":"Nwc"},{"l":"Example"},{"l":"How to use","p":["You need a nostr+walletconnect://... uri from your NWC wallet service provider.","see https://github.com/getAlby/awesome-nwc for more info how to get a wallet supporting NWC"]}],[{"l":"Relay sets"},{"l":"Example"},{"l":"When to use","p":["Calculates the best relays for a given set of pubkeys. It's used by inbox/outbox. This allows for granular control in the relaySets engine. E.g. calculating the best relays for a thread view."]}],[{"l":"Requests"},{"l":"Usage Example"},{"l":"When to use","p":["Requests should be used when no other use case fits your needs. There is .query and .subscription representing the nostr equivalent, .subscription should only be used when absolutely necessary. Many relays limit the amount of simultaneous subscriptions."]}],[{"l":"User relay lists"},{"l":"Example"},{"l":"When to use","p":["User relay lists provides you with the relays for a given user. It orients itself on nip65 but also uses data from nip02 in case nip65 is not available. It's used by inbox/outbox; only use this if you are doing something custom that is not directly handled by inbox/outbox."]}],[{"l":"Zaps"},{"l":"Example"},{"l":"How to use","p":["You need a nostr+walletconnect://... uri from your NWC wallet service provider.","see https://github.com/getAlby/awesome-nwc for more info how to get a wallet supporting NWC"]}],[{"l":"Concepts"}],[{"l":"Engines"},{"l":"Engines","p":["NDK ships with two network Engines. An Engine is part of the code that resolves nostr requests over the network and handles the WebSocket connections. Its used to handle the inbox/outbox (gossip) model efficiently.","Lists Engine: Precalculates the best possible relays based on nip65 data. During calculation relay connectivity is taken into account. This works by connecting and checking the health status of a relay before its added to the ranking pool. This method gets close to the optimal connections given a certain pubkey coverage.","Just in Time (JIT) Engine: JIT Engine does the ranking on the fly only for the missing coverage/pubkey. Healthy relays are assumed during ranking and replaced later on if a relay fails to connect. To Avoid rarely used relays and spawning a bunch of unessecary connections, already connected relays get a boost, and a usefulness score is considered for the ranking. For more information look here","Custom Engine If you want to implement your own engine with custom behavior you need to touch the following things:","implement NetworkEngine interface","write your response stream to networkController in the RequestState","if you need global state you can register your own data type in global_state.dart","initialize your engine in init.dart","The current state solution is not ideal because it requires coordination between the engine authors and not enforceable by code. If you have ideas how to improve this system, please reach out.","The network engine is only concerned about network requests! Caching and avoiding concurrency is handled by separate usecases. Take a look at requests.dart usecase to learn more."]}],[{"l":"Relay JIT Engine","p":["The idea is to resolve relays just in time as the requests from the library user stream in. This has the benefit that only the currently needed relays are connected, and requests get automatically split. This means that a request is sent only to the relay where it's most likely to receive an answer. This is useful to avoid duplicate data and battery concerns on mobile devices."]},{"l":"read strategies","p":["First the request handler looks at the filter in the request and decides on a strategy. This is done by switch case.","shows different strategies and their selection"]},{"l":"pubkey strategy","p":["This graphic shows the flow of the pubkey strategy.","shows how the req relover works"]},{"l":"steps","p":["The request is sent to the req resolver.","Matching with already known pubkey relay relationships. If a relay is found, the request is sent out for the specific pubkey and the desired coverage reduced by 1. In this case pub1(write) and pub2(write) are found","Same as step 2, but read and write doesn't match. Nothing is found.","Pub3(write) is found. pub4 matches but in the wrong rw direction.","Missing coverage for pub3(write) is decreased by 1.","pub4(write) is still not covered. Looking in nip65 data for a relay candidate. The nip65 ranking considers already connected relays.","A relay that is already connected covers pub4(write). Adding the relationship to the working array.","No nip65 data for pub(write) is found. Fallback to blast all strategy.","A relay candidate is found but not connected. Connection is established and pub4(write) is added."]},{"l":"relay lost connection","p":["This graphic shows what happens if a relay connection is lost or connection fails. displays what happens when connection is lost and how to recover When the connection fails we try to restore the connection. If that failes we look for a new relay candiate(s), like in the previous graphic step 6-7."]},{"l":"kick unused relays","p":["Shows the concept of a relay garbage collector for rarely used relays. introduction of usefulness score","Multiple websocket connections are expensive, over the lifetime of the app we might have connected relays that are dangling and not used anymore. To avoid this we introduce a usefulness score. The score is increased by 1 for every request that is sent to the relay. If the score is below a certain threshold the relay is disconnected."]},{"l":"Complexity","p":["The most complex part \"../../jit_engine\"\"../../jit_engine\"is the relay ranking with a complexity of O(e * r). e = number of events r = maximum number of relays per event \\","Typically these values range for e from 1-2000 (median 250) and for r from 1-20 (median 11) These estimates are based on a dataset of a public relay with a sample size of ~ 20000.","For mobile devices its easy to compute and the result can be cached on a per feed basis."]}],[{"l":"Gossip"},{"i":"gossipoutbox-model-of-relay-discovery-and-connectivity","l":"Gossip/outbox model of relay discovery and connectivity","p":["The simplest characterization of the gossip model is just this: reading the posts of people you follow from the relays that they wrote them to.","more details on https://mikedilger.com/gossip-model/"]}],[{"l":"Performance"},{"l":"Performance","p":["There are two main constrains that we aim for: battery/compute and network bandwidth.","network Inbox/Outbox (gossip) is our main pillar to help avoid unnecessary nostr requests. We try to leverage the cache as much as possible. Even splitting the users filters into smaller relay tailored filters if we know the relay has the information we need.","compute Right now the most compute intensive operation is verifying signatures. We use the cache to determine if we have already seen the event and only if it is unknown signature verification is done. To make the operation as optimized as possible we strongly recommend using RustEventVerifier() because it uses a separate thread for verification."]}],[{"l":"Common terminology","p":["-","bootstrapRelays","broadcastEvent","default relays to connect; Used to get Nip65 data","engine","explanation","get data once and close the request","get request","JIT","Just In Time, e.g. as it happens","optimized network resolver for nostr requests","postEvent, publishEvent","push event to nostr network/relays","query","seed relays, initial relays","simmilar to","stream of data","stream of events as they come in","subscription","term"]}],[{"i":"library-development","l":"Library development \uD83C\uDFD7Ô∏è"},{"l":"Setup","p":["Install prerequisites","run melos bootstrap to install all dependencies.","If you work on rust code ( packages/rust_verifier/rust_builder/rust) run flutter_rust_bridge_codegen generate --watch to generate the rust dart glue code.","Run build runner: (e.g for generating mocks) dart run build_runner build"]},{"l":"Architecture","p":["The repo is setup as a monorepo and packages are split to enable user choice of what to include. The main package is ndk which is the main entry point for the lib user. Other packages like rust_verifier or amber are optional and can be included if needed.","NDK uses Clean Architecture. Reasons for it being clear separation of concerns and therefore making it more accessible for future contributors. You can read more about it here.","For initialization we use presentation_layer/init.dart to assemble all dependencies, these are then exposed in presentation_layer/ndk.dart the main entry point for the lib user.","Global state is realized via a simple [GlobalState] object created by ndk.dart. The lib user is supposed to keep the [NDK] object in memory.","Other state objects are created on demand, for example [RequestState] for each request."]},{"l":"Folder Structure of ndk"}],[{"l":"ADRs"}],[{"i":"architecture-decision-record-layered-architecture","l":"Architecture Decision Record: Layered Architecture","p":["Title: Layered Architecture - folder structure"]},{"l":"status","p":["In progress","Updated on 26-06-2024"]},{"l":"contributors","p":["Main contributor(s): leo-lox","Reviewer(s): frnandu","final decision made by: frnandu, leo-lox"]},{"l":"Context and Problem Statement","p":["Right now files and folders follow a simple nip folder structure (each nip gets a folder). There are no clear guidelines on where to put stuff and how to attach other packages."]},{"l":"Main Proposal","p":["# contains configuration files","# contains our api design (makes usecases accessible to outside world)","# contracts","# external apis, websocket impl etc.","# integration_tests","# only internal code, no external dependencies!","# our entities e.g. data types","# our main code / business logic","# repository implementations (implementing domain_layer repos)","# type conversion e.g. json to entity","# unit tests","config/","data_layer/","data_sources/","domain_layer/","entities/","Implement a clear folder structure and a layered architecture that makes it easy to include third-party packages.","lib.dart # entrypoint, points to presentation_layer","lib/","models/","nipX # folders for nip specific code","presentation_layer/","project-root/","repositories/","shared/","tests/","The proposed structure looks like this:","The shared folder is there to make the transition easier. Ideally, shared schuld only contain business logic and therefore extend the use cases folder. It can also be used for pure functions that use our entities.","unit/","usecases/"]},{"l":"Consequences","p":["in terms of difficulty, impact on other teams or the whole codebase, time, budget, uncertainty, etc","Pros","It makes it easy to include third-party packages without breaking stuff in the future.","Clear separation of concerns. It makes it easier for other developers to contribute.","We can easily switch out different third-party components. (e.g. websocket)","Makes clear what is accessible to the user and what is not.","Easy to integrate bridge structure like a rust bridge.","Cons","Requires a lot of rearranging the code base.","Guidelines need to be enforced.","If we want to transition to a event driven architecture this could be possible by injecting a message bus into our usecases"]},{"l":"Alternative proposals","p":["none so far"]},{"l":"Final Notes","p":["Proposal Accepted. Going forward after merging of https://github.com/relaystr/ndk/tree/relay_jit_ranking https://github.com/relaystr/ndk/tree/split-relay-manager https://github.com/relaystr/ndk completed"]}]]